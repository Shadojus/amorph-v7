---
/**
 * AMORPH v7 - Detail Page
 * 
 * Einzelansicht eines Items mit Suchleiste und Perspektiven-Filter.
 * 
 * Security:
 * - Slug validation
 * - Path traversal protection
 */

import Base from '../layouts/Base.astro';
import { loadConfig, getAllPerspectives } from '../server/config';
import { getItem } from '../server/data';
import { renderValue } from '../morphs';
import type { RenderContext } from '../core/types';
import { validateSlug } from '../core/security';

// Get and validate slug from URL
const rawSlug = Astro.params.slug;
const slug = validateSlug(rawSlug);

if (!slug) {
  return Astro.redirect('/');
}

// Load config and item
await loadConfig();
const item = await getItem(slug);

if (!item) {
  return Astro.redirect('/404');
}

// Render context
const detailContext: RenderContext = {
  mode: 'single',
  itemCount: 1
};

// Get perspectives and field mapping
const perspectives = getAllPerspectives();
const fieldPerspectiveMap = item._fieldPerspective || {};

// Perspektiven-Farben - Matte Pastell-TÃ¶ne (nicht leuchtend, klar von Bio-Farben unterscheidbar)
const perspectiveColors: Record<string, string[]> = {
  culinary: ['rgba(180, 140, 120, 0.6)'],
  safety: ['rgba(170, 130, 140, 0.6)'],
  cultivation: ['rgba(120, 150, 130, 0.6)'],
  medicine: ['rgba(150, 140, 170, 0.6)'],
  chemistry: ['rgba(160, 140, 160, 0.6)'],
  ecology: ['rgba(130, 150, 120, 0.6)'],
  statistics: ['rgba(165, 155, 140, 0.6)'],
  geography: ['rgba(160, 135, 120, 0.6)'],
  temporal: ['rgba(170, 160, 130, 0.6)'],
  economy: ['rgba(165, 150, 115, 0.6)'],
  conservation: ['rgba(115, 150, 145, 0.6)'],
  culture: ['rgba(155, 140, 160, 0.6)'],
  research: ['rgba(140, 145, 160, 0.6)'],
  interactions: ['rgba(175, 145, 135, 0.6)'],
  identification: ['rgba(145, 155, 125, 0.6)']
};

// Ermittle verfÃ¼gbare Perspektiven dieser Spezies
const availablePerspectives = [...new Set(Object.values(fieldPerspectiveMap))].filter(Boolean) as string[];

// Alle Felder mit ihren Perspektiven
const fieldsWithPerspectives = Object.entries(item)
  .filter(([k]) => !['id', 'slug', 'name', 'bild', 'wissenschaftlich', 'image', 'scientific_name'].includes(k) && !k.startsWith('_'))
  .map(([key, value]) => ({
    key,
    value,
    perspective: fieldPerspectiveMap[key] || null
  }));
---

<Base title={`${item.name} â€“ AMORPH`}>
  <!-- Perspektiven-Daten fÃ¼r Client -->
  <script define:vars={{ perspectiveColors, perspectives, availablePerspectives, fieldPerspectiveMap }}>
    window.AMORPH_PERSPECTIVE_COLORS = perspectiveColors;
    window.AMORPH_PERSPECTIVES = perspectives;
    window.AMORPH_AVAILABLE_PERSPECTIVES = availablePerspectives;
    window.AMORPH_FIELD_PERSPECTIVE_MAP = fieldPerspectiveMap;
  </script>

  <!-- Header -->
  <header class="amorph-header">
    <a href="/" class="amorph-logo">ğŸ„</a>
    <h1 class="page-title">{item.name}</h1>
    <a href="/" class="back-link">â† ZurÃ¼ck</a>
  </header>
  
  <!-- Aktive Perspektiven unter Header -->
  <div class="active-perspectives-bar">
    <div class="active-perspectives"></div>
  </div>
  
  <!-- Detail View -->
  <main class="amorph-detail">
    <!-- Hero Section -->
    <section class="detail-hero">
      {(item.bild || item.image) && (
        <div class="hero-image">
          <img src={String(item.bild || item.image)} alt={item.name} />
        </div>
      )}
      
      <div class="hero-info">
        <h1>{item.name}</h1>
        {(item.wissenschaftlich || item.scientific_name) && (
          <p class="scientific-name">{String(item.wissenschaftlich || item.scientific_name)}</p>
        )}
      </div>
    </section>
    
    <!-- Fields Container (filterable) -->
    <section class="detail-fields" data-field-perspectives={JSON.stringify(fieldPerspectiveMap)}>
      {fieldsWithPerspectives.map(({ key, value, perspective }) => (
        <div class="detail-field" data-field-key={key} data-perspective={perspective || ''}>
          <Fragment set:html={renderValue(value, key, detailContext)} />
        </div>
      ))}
    </section>
    
    <!-- Actions -->
    <section class="detail-actions">
      <button 
        class="action-btn select-for-compare"
        data-slug={item.slug}
        data-name={item.name}
      >
        Zum Vergleich hinzufÃ¼gen
      </button>
    </section>
  </main>
  
  <!-- Search Footer (gleich wie index.astro) -->
  <footer class="amorph-search-footer">
    <div class="search-footer-inner">
      <div class="amorph-search">
        <div class="search-wrapper">
          <span class="search-icon">ğŸ”</span>
          <input 
            type="search" 
            placeholder="In dieser Spezies suchen..." 
            autocomplete="off"
          />
          <div class="search-nav" style="display: none;">
            <span class="search-nav-count">0/0</span>
            <button type="button" class="search-nav-prev" aria-label="Vorheriger Treffer">â†‘</button>
            <button type="button" class="search-nav-next" aria-label="NÃ¤chster Treffer">â†“</button>
          </div>
        </div>
      </div>
    </div>
  </footer>
</Base>

<script>
  /**
   * Detail Page Client Script
   * Suchfunktion und Perspektiven-Filterung fÃ¼r einzelne Spezies
   */
  
  // State
  let activePerspectives: Set<string> = new Set();
  let searchTimeout: number | null = null;
  let currentHighlightIndex = 0;
  let highlightElements: HTMLElement[] = [];
  let lastSearchQuery = ''; // Track last query to detect changes
  
  const DEBOUNCE_MS = 200;
  
  // DOM Elements
  const searchInput = document.querySelector<HTMLInputElement>('.amorph-search input');
  const fieldsContainer = document.querySelector<HTMLElement>('.detail-fields');
  const activePerspectivesContainer = document.querySelector<HTMLElement>('.active-perspectives');
  const searchNavContainer = document.querySelector<HTMLElement>('.search-nav');
  
  // Global data
  const perspectives = (window as any).AMORPH_PERSPECTIVES || [];
  const availablePerspectives = (window as any).AMORPH_AVAILABLE_PERSPECTIVES || [];
  const fieldPerspectiveMap = (window as any).AMORPH_FIELD_PERSPECTIVE_MAP || {};
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SEARCH
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // Helper: Normalisiere String fÃ¼r Suche (Unterstriche = Leerzeichen)
  function normalizeForSearch(str: string): string {
    return str.toLowerCase().replace(/_/g, ' ');
  }
  
  function filterFields(): void {
    if (!fieldsContainer) return;
    
    const query = searchInput?.value.trim().toLowerCase() || '';
    const queryNormalized = normalizeForSearch(query);
    const fields = fieldsContainer.querySelectorAll<HTMLElement>('.detail-field');
    
    fields.forEach(field => {
      const fieldKey = field.dataset.fieldKey || '';
      const perspective = field.dataset.perspective || '';
      const textContent = field.textContent?.toLowerCase() || '';
      
      // Normalisierte Versionen fÃ¼r Matching
      const keyNormalized = normalizeForSearch(fieldKey);
      const textNormalized = normalizeForSearch(textContent);
      
      // PrÃ¼fe Suchbegriff-Match (mit Underscore/Space Normalisierung)
      const matchesQuery = !query || query.length < 3 || 
        textContent.includes(query) || textNormalized.includes(queryNormalized) ||
        fieldKey.toLowerCase().includes(query) || keyNormalized.includes(queryNormalized);
      
      // PrÃ¼fe Perspektiven-Filter
      const matchesPerspective = activePerspectives.size === 0 || 
        (perspective && activePerspectives.has(perspective));
      
      // Zeige/Verstecke Feld
      if (matchesQuery && matchesPerspective) {
        field.style.display = '';
      } else {
        field.style.display = 'none';
      }
    });
  }
  
  function performSearch(): void {
    const query = searchInput?.value.trim().toLowerCase() || '';
    
    if (!fieldsContainer) return;
    
    // Reset Perspektiven nur wenn sich der Query geÃ¤ndert hat (neuer Suchbegriff)
    // Nicht wenn performSearch durch Perspektiven-Klick aufgerufen wird
    if (query !== lastSearchQuery && query.length >= 1) {
      activePerspectives.clear();
      updateActivePerspectivesUI();
    }
    lastSearchQuery = query;
    
    // Alle Felder durchgehen und Matches sammeln
    const fields = fieldsContainer.querySelectorAll<HTMLElement>('.detail-field');
    let matchedPerspectives: Set<string> = new Set();
    
    fields.forEach(field => {
      const fieldKey = field.dataset.fieldKey || '';
      const perspective = field.dataset.perspective || '';
      const textContent = field.textContent?.toLowerCase() || '';
      
      // Sammle Perspektiven mit Treffern
      if (query.length >= 3 && (textContent.includes(query) || fieldKey.toLowerCase().includes(query)) && perspective) {
        matchedPerspectives.add(perspective);
      }
    });
    
    // Auto-Aktiviere gefundene Perspektiven (ab 3 Zeichen, max 3)
    if (query.length >= 3 && matchedPerspectives.size > 0 && matchedPerspectives.size <= 3) {
      matchedPerspectives.forEach(pId => {
        if (!activePerspectives.has(pId)) {
          activePerspectives.add(pId);
        }
      });
      updateActivePerspectivesUI();
    }
    
    // Felder filtern
    filterFields();
    
    // Highlighting
    updateHighlighting(query);
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PERSPECTIVES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function updateActivePerspectivesUI(): void {
    if (!activePerspectivesContainer) return;
    
    activePerspectivesContainer.innerHTML = '';
    
    for (const id of activePerspectives) {
      const perspData = perspectives.find((p: any) => p.id === id);
      const name = perspData?.name || id;
      
      const pill = document.createElement('button');
      pill.className = 'active-persp-pill';
      pill.dataset.perspektive = id;
      pill.innerHTML = `<span>${name}</span><span class="remove">Ã—</span>`;
      pill.addEventListener('click', () => {
        activePerspectives.delete(id);
        updateActivePerspectivesUI();
        filterFields(); // Nur Felder neu filtern, nicht komplette Suche
      });
      
      activePerspectivesContainer.appendChild(pill);
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HIGHLIGHTING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function updateHighlighting(query: string): void {
    if (!fieldsContainer) return;
    
    // Entferne alte Highlights
    fieldsContainer.querySelectorAll('mark.search-highlight').forEach(mark => {
      const parent = mark.parentNode;
      if (parent) {
        parent.replaceChild(document.createTextNode(mark.textContent || ''), mark);
        parent.normalize();
      }
    });
    
    if (!query || query.length < 3) {
      if (searchNavContainer) searchNavContainer.style.display = 'none';
      highlightElements = [];
      return;
    }
    
    const lowerQuery = query.toLowerCase();
    // Flexibles Regex: Leerzeichen und Unterstriche sind Ã¤quivalent
    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const flexiblePattern = escapedQuery.replace(/[\s_]+/g, '[\\s_]+');
    const flexibleRegex = new RegExp(`(${flexiblePattern})`, 'gi');
    
    // Suchvarianten fÃ¼r Textknoten-Filter
    const searchVariants = [
      lowerQuery,
      lowerQuery.replace(/\s+/g, '_'),
      lowerQuery.replace(/_/g, ' ')
    ];
    
    // Nur sichtbare Felder highlighten
    const visibleFields = fieldsContainer.querySelectorAll<HTMLElement>('.detail-field:not([style*="display: none"])');
    
    visibleFields.forEach(field => {
      const walker = document.createTreeWalker(
        field,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: (node) => {
            if (!node.textContent?.trim()) return NodeFilter.FILTER_REJECT;
            if (node.parentElement?.closest('mark')) return NodeFilter.FILTER_REJECT;
            if (node.parentElement?.closest('script')) return NodeFilter.FILTER_REJECT;
            // PrÃ¼fe alle Varianten
            const textLower = node.textContent.toLowerCase();
            const textNormalized = textLower.replace(/_/g, ' ');
            const matches = searchVariants.some(v => 
              textLower.includes(v) || textNormalized.includes(v.replace(/_/g, ' '))
            );
            if (!matches) return NodeFilter.FILTER_REJECT;
            return NodeFilter.FILTER_ACCEPT;
          }
        }
      );
      
      const textNodes: Text[] = [];
      let node: Text | null;
      while ((node = walker.nextNode() as Text | null)) {
        textNodes.push(node);
      }
      
      for (const textNode of textNodes) {
        const text = textNode.textContent || '';
        flexibleRegex.lastIndex = 0;
        if (!flexibleRegex.test(text)) continue;
        flexibleRegex.lastIndex = 0;
        
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match: RegExpExecArray | null;
        
        while ((match = flexibleRegex.exec(text)) !== null) {
          if (match.index > lastIndex) {
            fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
          }
          const mark = document.createElement('mark');
          mark.className = 'search-highlight';
          mark.textContent = match[1];
          fragment.appendChild(mark);
          lastIndex = regex.lastIndex;
        }
        
        if (lastIndex < text.length) {
          fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
        }
        
        textNode.parentNode?.replaceChild(fragment, textNode);
      }
    });
    
    // Update navigation
    highlightElements = Array.from(document.querySelectorAll('.search-highlight')) as HTMLElement[];
    currentHighlightIndex = 0;
    
    if (searchNavContainer) {
      if (highlightElements.length > 0) {
        searchNavContainer.style.display = 'flex';
        updateHighlightCounter();
        if (highlightElements[0]) {
          scrollToHighlight(0);
        }
      } else {
        searchNavContainer.style.display = 'none';
      }
    }
  }
  
  function navigateHighlight(direction: number): void {
    if (highlightElements.length === 0) return;
    
    highlightElements[currentHighlightIndex]?.classList.remove('is-current');
    
    currentHighlightIndex += direction;
    if (currentHighlightIndex >= highlightElements.length) {
      currentHighlightIndex = 0;
    } else if (currentHighlightIndex < 0) {
      currentHighlightIndex = highlightElements.length - 1;
    }
    
    scrollToHighlight(currentHighlightIndex);
    updateHighlightCounter();
  }
  
  function scrollToHighlight(index: number): void {
    const element = highlightElements[index];
    if (!element) return;
    
    highlightElements.forEach(el => el.classList.remove('is-current'));
    element.classList.add('is-current');
    
    element.scrollIntoView({
      behavior: 'smooth',
      block: 'center'
    });
  }
  
  function updateHighlightCounter(): void {
    const countEl = document.querySelector('.search-nav-count');
    if (countEl) {
      countEl.textContent = `${currentHighlightIndex + 1}/${highlightElements.length}`;
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INIT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // Search input handler
  searchInput?.addEventListener('input', () => {
    if (searchTimeout) clearTimeout(searchTimeout);
    searchTimeout = window.setTimeout(performSearch, DEBOUNCE_MS);
  });
  
  searchInput?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      if (highlightElements.length > 0) {
        navigateHighlight(e.shiftKey ? -1 : 1);
      } else {
        if (searchTimeout) clearTimeout(searchTimeout);
        performSearch();
      }
    }
  });
  
  // Navigation buttons
  document.querySelector('.search-nav-prev')?.addEventListener('click', () => navigateHighlight(-1));
  document.querySelector('.search-nav-next')?.addEventListener('click', () => navigateHighlight(1));
  
  // Compare button
  document.querySelector('.select-for-compare')?.addEventListener('click', (e) => {
    const btn = e.currentTarget as HTMLElement;
    const slug = btn.dataset.slug;
    const name = btn.dataset.name;
    
    if (slug && name) {
      import('../client/features').then(({ selectItem }) => {
        selectItem({
          id: slug,
          slug,
          name,
          data: {}
        });
      });
    }
  });
  
  console.log('[Detail] Initialized with', availablePerspectives.length, 'perspectives');
</script>

<style>
  /* Detail-spezifische Styles */
  .detail-field {
    transition: opacity 0.2s ease;
  }
  
  .detail-field[style*="display: none"] {
    opacity: 0;
  }
</style>
