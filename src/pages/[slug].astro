---
/**
 * AMORPH v7 - Detail Page
 * 
 * Einzelansicht eines Items mit Suchleiste und Perspektiven-Filter.
 * 
 * Security:
 * - Slug validation
 * - Path traversal protection
 */

import Base from '../layouts/Base.astro';
import { loadConfig, getAllPerspectives } from '../server/config';
import { getItem } from '../server/data';
import { renderValue } from '../morphs';
import type { RenderContext } from '../core/types';
import { validateSlug } from '../core/security';

// Get and validate slug from URL
const rawSlug = Astro.params.slug;

// Wenn kein slug vorhanden ist, 404 zurÃ¼ckgeben
// (Astro sollte "/" automatisch zu index.astro routen)
if (!rawSlug || rawSlug === '') {
  return new Response(null, { status: 404 });
}

const slug = validateSlug(rawSlug);

if (!slug) {
  return new Response(null, { status: 404 });
}

// Load config and item
await loadConfig();
const item = await getItem(slug);

if (!item) {
  return Astro.redirect('/404');
}

// Render context
const detailContext: RenderContext = {
  mode: 'single',
  itemCount: 1
};

// Get perspectives and field mapping
const perspectives = getAllPerspectives();
const fieldPerspectiveMap = item._fieldPerspective || {};

// Perspektiven-Farben - Matte Pastell-TÃ¶ne (nicht leuchtend, klar von Bio-Farben unterscheidbar)
const perspectiveColors: Record<string, string[]> = {
  culinary: ['rgba(180, 140, 120, 0.2)'],
  safety: ['rgba(170, 130, 140, 0.2)'],
  cultivation: ['rgba(120, 150, 130, 0.2)'],
  medicine: ['rgba(150, 140, 170, 0.2)'],
  chemistry: ['rgba(160, 140, 160, 0.2)'],
  ecology: ['rgba(130, 150, 120, 0.2)'],
  statistics: ['rgba(165, 155, 140, 0.2)'],
  geography: ['rgba(160, 135, 120, 0.2)'],
  temporal: ['rgba(170, 160, 130, 0.2)'],
  economy: ['rgba(165, 150, 115, 0.2)'],
  conservation: ['rgba(115, 150, 145, 0.2)'],
  culture: ['rgba(155, 140, 160, 0.2)'],
  research: ['rgba(140, 145, 160, 0.2)'],
  interactions: ['rgba(175, 145, 135, 0.2)'],
  identification: ['rgba(145, 155, 125, 0.2)']
};

// Ermittle verfÃ¼gbare Perspektiven dieser Spezies
const availablePerspectives = [...new Set(Object.values(fieldPerspectiveMap))].filter(Boolean) as string[];

// Alle Felder mit ihren Perspektiven
const fieldsWithPerspectives = Object.entries(item)
  .filter(([k]) => !['id', 'slug', 'name', 'bild', 'wissenschaftlich', 'image', 'scientific_name'].includes(k) && !k.startsWith('_'))
  .map(([key, value]) => ({
    key,
    value,
    perspective: fieldPerspectiveMap[key] || null
  }));
---

<Base title={`${item.name} â€“ AMORPH`}>
  <!-- Perspektiven-Daten fÃ¼r Client -->
  <script define:vars={{ perspectiveColors, perspectives, availablePerspectives, fieldPerspectiveMap }}>
    window.AMORPH_PERSPECTIVE_COLORS = perspectiveColors;
    window.AMORPH_PERSPECTIVES = perspectives;
    window.AMORPH_AVAILABLE_PERSPECTIVES = availablePerspectives;
    window.AMORPH_FIELD_PERSPECTIVE_MAP = fieldPerspectiveMap;
  </script>

  <!-- Header mit ZurÃ¼ck-Navigation -->
  <header class="amorph-header amorph-header--detail">
    <a href="/" class="detail-back" title="ZurÃ¼ck zur Ãœbersicht">
      <span class="detail-back-icon">â†</span>
      <span class="detail-back-label">Ãœbersicht</span>
    </a>
    <div class="detail-title">
      <h1 class="page-title">{item.name}</h1>
      {(item.wissenschaftlich || item.scientific_name) && (
        <span class="page-subtitle">{String(item.wissenschaftlich || item.scientific_name)}</span>
      )}
    </div>
    <div class="detail-actions-header">
      <span class="selection-indicator">
        <span class="selection-indicator-count">0</span>
        <span class="selection-indicator-icon">âœ“</span>
      </span>
    </div>
  </header>
  
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SEARCH BAR - Wie auf Startseite mit Perspektiven-Switch
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="search-bar-container">
    <div class="search-bar-inner">
      <div class="search-input-wrapper">
        <span class="search-icon">ğŸ”</span>
        <input 
          type="search" 
          class="search-input-main"
          placeholder="In dieser Spezies suchen..." 
          autocomplete="off"
        />
        <div class="search-nav" style="display: none;">
          <span class="search-nav-count">0/0</span>
          <button type="button" class="search-nav-prev" aria-label="Vorheriger Treffer">â†‘</button>
          <button type="button" class="search-nav-next" aria-label="NÃ¤chster Treffer">â†“</button>
        </div>
      </div>
    </div>
    <!-- Aktive Perspektiven unter Suche -->
    <div class="active-perspectives"></div>
  </div>
  
  <!-- Detail View -->
  <main class="amorph-detail">
    <!-- Hero Section -->
    <section class="detail-hero">
      {(item.bild || item.image) && (
        <div class="hero-image">
          <img src={String(item.bild || item.image)} alt={item.name} />
        </div>
      )}
      
      <div class="hero-info">
        <h1>{item.name}</h1>
        {(item.wissenschaftlich || item.scientific_name) && (
          <p class="scientific-name">{String(item.wissenschaftlich || item.scientific_name)}</p>
        )}
      </div>
    </section>
    
    <!-- Fields Container (filterable) - mit Slug fÃ¼r Selection -->
    <section 
      class="detail-fields" 
      data-field-perspectives={JSON.stringify(fieldPerspectiveMap)}
      data-item-slug={item.slug}
      data-item-name={item.name}
    >
      {fieldsWithPerspectives.map(({ key, value, perspective }) => (
        <div class="detail-field" data-field-key={key} data-perspective={perspective || ''}>
          <Fragment set:html={renderValue(value, key, detailContext)} />
        </div>
      ))}
    </section>
  </main>
  
  <!-- Selection Bar (wie index.astro) -->
  <div class="selection-bar">
    <div class="selection-pills"></div>
    <span class="selection-count">0 ausgewÃ¤hlt</span>
    <button class="selection-clear">Alle entfernen</button>
  </div>
  
  <!-- Compare Panel (Overlay) -->
  <aside class="amorph-compare">
    <div class="compare-header">
      <h2>Vergleich</h2>
      <div class="compare-header-actions">
        <button class="compare-copy" title="Daten kopieren">
          <span class="copy-icon">ğŸ“‹</span>
          <span class="copy-label">Kopieren</span>
        </button>
        <button class="compare-close">Ã—</button>
      </div>
    </div>
    <div class="compare-license-notice">
      <span class="license-icon">ğŸ“–</span>
      <span>Free License â€“ Bei Nutzung bitte Quelle angeben</span>
    </div>
    <div class="compare-content">
      <!-- Filled via JS -->
    </div>
  </aside>
  
  <!-- Footer -->
  <footer class="amorph-footer">
    <div class="footer-content">
      <nav class="footer-links">
        <a href="/impressum" class="footer-link">Impressum</a>
        <a href="/datenschutz" class="footer-link">Datenschutz</a>
        <a href="/about" class="footer-link">Ãœber AMORPH</a>
      </nav>
      <p class="footer-copyright">Â© 2025 AMORPH</p>
    </div>
  </footer>
  
  <!-- Bottom Navigation (wie index.astro) -->
  <nav class="bottom-nav">
    <a href="/" class="bottom-nav-item" data-nav="home" aria-label="ZurÃ¼ck zur Ãœbersicht">
      <svg class="bottom-nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
        <polyline points="9 22 9 12 15 12 15 22"/>
      </svg>
      <span class="bottom-nav-label">Home</span>
    </a>
    <button type="button" class="bottom-nav-item" data-nav="compare" aria-label="Vergleichen">
      <svg class="bottom-nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2v-4M9 21H5a2 2 0 0 1-2-2v-4"/>
      </svg>
      <span class="bottom-nav-label">Vergleich</span>
      <span class="bottom-nav-badge">0</span>
    </button>
    <a href="/bifroest" class="bottom-nav-item" data-nav="bifroest" aria-label="BifrÃ¶st Portal">
      <svg class="bottom-nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 2L2 7l10 5 10-5-10-5z"/>
        <path d="m2 17 10 5 10-5"/>
        <path d="m2 12 10 5 10-5"/>
      </svg>
      <span class="bottom-nav-label">BifrÃ¶st</span>
    </a>
  </nav>
</Base>

<script>
  /**
   * Detail Page Client Script
   * Suchfunktion mit Perspektiven-Switch und Feld-Selection
   */
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STATE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  let activePerspectives: Set<string> = new Set();
  let searchTimeout: number | null = null;
  let currentHighlightIndex = 0;
  let highlightElements: HTMLElement[] = [];
  let lastSearchQuery = '';
  
  const DEBOUNCE_MS = 200;
  
  // DOM Elements
  const searchInput = document.querySelector<HTMLInputElement>('.search-input-main');
  const fieldsContainer = document.querySelector<HTMLElement>('.detail-fields');
  const activePerspectivesContainer = document.querySelector<HTMLElement>('.active-perspectives');
  const searchNavContainer = document.querySelector<HTMLElement>('.search-nav');
  
  // Global data
  const perspectives = (window as any).AMORPH_PERSPECTIVES || [];
  const availablePerspectives = (window as any).AMORPH_AVAILABLE_PERSPECTIVES || [];
  const fieldPerspectiveMap = (window as any).AMORPH_FIELD_PERSPECTIVE_MAP || {};
  const perspectiveColors = (window as any).AMORPH_PERSPECTIVE_COLORS || {};
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SEARCH
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function normalizeForSearch(str: string): string {
    return str.toLowerCase().replace(/_/g, ' ');
  }
  
  function filterFields(): void {
    if (!fieldsContainer) return;
    
    const query = searchInput?.value.trim().toLowerCase() || '';
    const queryNormalized = normalizeForSearch(query);
    const fields = fieldsContainer.querySelectorAll<HTMLElement>('.detail-field');
    
    fields.forEach(field => {
      const fieldKey = field.dataset.fieldKey || '';
      const perspective = field.dataset.perspective || '';
      const textContent = field.textContent?.toLowerCase() || '';
      
      const keyNormalized = normalizeForSearch(fieldKey);
      const textNormalized = normalizeForSearch(textContent);
      
      const matchesQuery = !query || query.length < 3 || 
        textContent.includes(query) || textNormalized.includes(queryNormalized) ||
        fieldKey.toLowerCase().includes(query) || keyNormalized.includes(queryNormalized);
      
      const matchesPerspective = activePerspectives.size === 0 || 
        (perspective && activePerspectives.has(perspective));
      
      field.style.display = (matchesQuery && matchesPerspective) ? '' : 'none';
    });
  }
  
  function performSearch(): void {
    const query = searchInput?.value.trim().toLowerCase() || '';
    
    if (!fieldsContainer) return;
    
    if (query !== lastSearchQuery && query.length >= 1) {
      activePerspectives.clear();
      updateActivePerspectivesUI();
    }
    lastSearchQuery = query;
    
    const fields = fieldsContainer.querySelectorAll<HTMLElement>('.detail-field');
    let matchedPerspectives: Set<string> = new Set();
    
    fields.forEach(field => {
      const fieldKey = field.dataset.fieldKey || '';
      const perspective = field.dataset.perspective || '';
      const textContent = field.textContent?.toLowerCase() || '';
      
      if (query.length >= 3 && (textContent.includes(query) || fieldKey.toLowerCase().includes(query)) && perspective) {
        matchedPerspectives.add(perspective);
      }
    });
    
    if (query.length >= 3 && matchedPerspectives.size > 0 && matchedPerspectives.size <= 3) {
      matchedPerspectives.forEach(pId => activePerspectives.add(pId));
      updateActivePerspectivesUI();
    }
    
    filterFields();
    updateHighlighting(query);
    
    // Auch Compare-View durchsuchen wenn aktiv
    searchCompareView(query);
  }
  
  // Compare-View Suche
  async function searchCompareView(query: string): Promise<void> {
    try {
      const { isCompareOpen, searchInCompare, getCompareHighlightInfo } = await import('../client/features');
      
      if (isCompareOpen() && query.length >= 2) {
        const result = searchInCompare(query);
        const info = getCompareHighlightInfo();
        
        // Update search nav counter to include compare results
        if (result.count > 0) {
          const navCount = document.querySelector('.search-nav-count');
          if (navCount) {
            const detailCount = highlightElements.length;
            navCount.textContent = `${info.current}/${result.count} (Compare)`;
          }
        }
      }
    } catch (e) {
      // Features not loaded yet
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PERSPECTIVES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function getPerspectiveColor(perspectiveId: string): string | null {
    if (!perspectiveColors[perspectiveId]) return null;
    const colors = perspectiveColors[perspectiveId];
    return colors && colors.length > 0 ? colors[0] : null;
  }
  
  function updateActivePerspectivesUI(): void {
    if (!activePerspectivesContainer) return;
    
    activePerspectivesContainer.innerHTML = '';
    
    for (const id of activePerspectives) {
      const perspData = perspectives.find((p: any) => p.id === id);
      const name = perspData?.name || id;
      const color = getPerspectiveColor(id) || 'rgba(77, 136, 255, 0.75)';
      
      const pill = document.createElement('button');
      pill.className = 'active-persp-pill';
      pill.dataset.perspektive = id;
      pill.style.setProperty('--persp-color', color);
      pill.innerHTML = `<span>${name}</span><span class="remove">Ã—</span>`;
      pill.addEventListener('click', () => {
        activePerspectives.delete(id);
        updateActivePerspectivesUI();
        filterFields();
      });
      
      activePerspectivesContainer.appendChild(pill);
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HIGHLIGHTING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function updateHighlighting(query: string): void {
    if (!fieldsContainer) return;
    
    // Remove old highlights
    fieldsContainer.querySelectorAll('mark.search-highlight').forEach(mark => {
      const parent = mark.parentNode;
      if (parent) {
        parent.replaceChild(document.createTextNode(mark.textContent || ''), mark);
        parent.normalize();
      }
    });
    
    if (!query || query.length < 3) {
      if (searchNavContainer) searchNavContainer.style.display = 'none';
      highlightElements = [];
      return;
    }
    
    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const flexiblePattern = escapedQuery.replace(/[\s_]+/g, '[\\s_]+');
    const flexibleRegex = new RegExp(`(${flexiblePattern})`, 'gi');
    
    const searchVariants = [
      query.toLowerCase(),
      query.toLowerCase().replace(/\s+/g, '_'),
      query.toLowerCase().replace(/_/g, ' ')
    ];
    
    const visibleFields = fieldsContainer.querySelectorAll<HTMLElement>('.detail-field:not([style*="display: none"])');
    
    visibleFields.forEach(field => {
      const walker = document.createTreeWalker(
        field,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: (node) => {
            if (!node.textContent?.trim()) return NodeFilter.FILTER_REJECT;
            if (node.parentElement?.closest('mark')) return NodeFilter.FILTER_REJECT;
            if (node.parentElement?.closest('script')) return NodeFilter.FILTER_REJECT;
            const textLower = node.textContent.toLowerCase();
            const textNormalized = textLower.replace(/_/g, ' ');
            const matches = searchVariants.some(v => 
              textLower.includes(v) || textNormalized.includes(v.replace(/_/g, ' '))
            );
            return matches ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
          }
        }
      );
      
      const textNodes: Text[] = [];
      let node: Text | null;
      while ((node = walker.nextNode() as Text | null)) {
        textNodes.push(node);
      }
      
      for (const textNode of textNodes) {
        const text = textNode.textContent || '';
        flexibleRegex.lastIndex = 0;
        if (!flexibleRegex.test(text)) continue;
        flexibleRegex.lastIndex = 0;
        
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match: RegExpExecArray | null;
        
        while ((match = flexibleRegex.exec(text)) !== null) {
          if (match.index > lastIndex) {
            fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
          }
          const mark = document.createElement('mark');
          mark.className = 'search-highlight';
          mark.textContent = match[1];
          fragment.appendChild(mark);
          lastIndex = flexibleRegex.lastIndex;
        }
        
        if (lastIndex < text.length) {
          fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
        }
        
        textNode.parentNode?.replaceChild(fragment, textNode);
      }
    });
    
    highlightElements = Array.from(document.querySelectorAll('.search-highlight')) as HTMLElement[];
    currentHighlightIndex = 0;
    
    if (searchNavContainer) {
      if (highlightElements.length > 0) {
        searchNavContainer.style.display = 'flex';
        updateHighlightCounter();
        scrollToHighlight(0);
      } else {
        searchNavContainer.style.display = 'none';
      }
    }
  }
  
  function navigateHighlight(direction: number): void {
    if (highlightElements.length === 0) return;
    
    highlightElements[currentHighlightIndex]?.classList.remove('is-current');
    
    currentHighlightIndex += direction;
    if (currentHighlightIndex >= highlightElements.length) {
      currentHighlightIndex = 0;
    } else if (currentHighlightIndex < 0) {
      currentHighlightIndex = highlightElements.length - 1;
    }
    
    scrollToHighlight(currentHighlightIndex);
    updateHighlightCounter();
  }
  
  function scrollToHighlight(index: number): void {
    const element = highlightElements[index];
    if (!element) return;
    
    highlightElements.forEach(el => el.classList.remove('is-current'));
    element.classList.add('is-current');
    element.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }
  
  function updateHighlightCounter(): void {
    const countEl = document.querySelector('.search-nav-count');
    if (countEl) {
      countEl.textContent = `${currentHighlightIndex + 1}/${highlightElements.length}`;
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SEARCH INIT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  searchInput?.addEventListener('input', () => {
    if (searchTimeout) clearTimeout(searchTimeout);
    searchTimeout = window.setTimeout(performSearch, DEBOUNCE_MS);
  });
  
  searchInput?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      if (highlightElements.length > 0) {
        navigateHighlight(e.shiftKey ? -1 : 1);
      } else {
        if (searchTimeout) clearTimeout(searchTimeout);
        performSearch();
      }
    }
  });
  
  document.querySelector('.search-nav-prev')?.addEventListener('click', () => navigateHighlight(-1));
  document.querySelector('.search-nav-next')?.addEventListener('click', () => navigateHighlight(1));
  
  console.log('[Detail] Search initialized');
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FIELD SELECTION - Mit Perspektiven-Farben
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // Wait for DOM to be fully ready
  function initFieldSelection(): void {
    import('../client/features').then((features) => {
      const {
        loadFromStorage,
        selectField,
        deselectField,
        isFieldSelected,
        getFieldColor,
        getSelectedFieldCount,
        getSelectedFields,
        clearSelection,
        subscribe
      } = features;
    
    // Compare wird bereits von initApp() in Base.astro initialisiert
    // Kein erneuter initCompare-Aufruf nÃ¶tig
    
    loadFromStorage();
    
    const itemSlug = fieldsContainer?.dataset.itemSlug || '';
    const itemName = fieldsContainer?.dataset.itemName || '';
    
    const selectionBar = document.querySelector<HTMLElement>('.selection-bar');
    const selectionPills = document.querySelector<HTMLElement>('.selection-pills');
    const selectionCount = document.querySelector<HTMLElement>('.selection-count');
    const selectionClear = document.querySelector<HTMLElement>('.selection-clear');
    const bottomNavBadge = document.querySelector<HTMLElement>('.bottom-nav-badge');
    
    function applySelectionColor(field: HTMLElement, color: string): void {
      const rgbaMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (rgbaMatch) {
        const [, r, g, b] = rgbaMatch;
        field.style.setProperty('--selection-color', `rgba(${r}, ${g}, ${b}, 0.9)`);
        field.style.setProperty('--selection-bg', `rgba(${r}, ${g}, ${b}, 0.04)`);
        field.style.setProperty('--selection-border', `rgba(${r}, ${g}, ${b}, 0.5)`);
      }
    }
    
    function getFieldValue(field: HTMLElement): unknown {
      const amorphField = field.querySelector('.amorph-field') as HTMLElement;
      if (amorphField?.dataset.rawValue) {
        try {
          return JSON.parse(atob(amorphField.dataset.rawValue.replace(/\s/g, '')));
        } catch (e) {}
      }
      return field.querySelector('.amorph-field-value')?.textContent?.trim() || null;
    }
    
    function handleFieldClick(e: Event): void {
      const target = e.target as HTMLElement;
      const amorphField = target.closest('.amorph-field') as HTMLElement;
      if (!amorphField) return;
      
      const detailField = amorphField.closest('.detail-field') as HTMLElement;
      if (!detailField) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      const fieldName = amorphField.dataset.field || detailField.dataset.fieldKey || '';
      const perspective = detailField.dataset.perspective || '';
      
      if (amorphField.classList.contains('is-selected')) {
        amorphField.classList.remove('is-selected');
        amorphField.style.removeProperty('--selection-color');
        amorphField.style.removeProperty('--selection-bg');
        amorphField.style.removeProperty('--selection-border');
        deselectField(itemSlug, fieldName);
      } else {
        // Use perspective color for selection
        const color = perspective ? (getPerspectiveColor(perspective) || 'rgba(77, 136, 255, 0.75)') : 'rgba(77, 136, 255, 0.75)';
        selectField(itemSlug, itemName, fieldName, getFieldValue(detailField), perspective || undefined);
        applySelectionColor(amorphField, color);
        amorphField.classList.add('is-selected');
      }
      
      updateSelectionUI();
    }
    
    function updateSelectionUI(): void {
      const count = getSelectedFieldCount();
      const fields = getSelectedFields();
      
      if (selectionCount) selectionCount.textContent = `${count} ausgewÃ¤hlt`;
      if (bottomNavBadge) {
        bottomNavBadge.textContent = String(count);
        bottomNavBadge.style.display = count > 0 ? 'flex' : 'none';
      }
      if (selectionBar) selectionBar.classList.toggle('is-visible', count > 0);
      
      const headerIndicator = document.querySelector('.selection-indicator');
      const headerIndicatorCount = document.querySelector('.selection-indicator-count');
      if (headerIndicator) headerIndicator.classList.toggle('is-visible', count > 0);
      if (headerIndicatorCount) headerIndicatorCount.textContent = String(count);
      
      if (selectionPills) {
        selectionPills.innerHTML = '';
        fields.forEach(f => {
          const pill = document.createElement('span');
          pill.className = 'selection-pill';
          pill.style.setProperty('--pill-color', f.color);
          pill.innerHTML = `<span class="pill-field">${f.fieldName}</span><span class="pill-item">${f.itemName}</span>`;
          selectionPills.appendChild(pill);
        });
      }
      
      fieldsContainer?.querySelectorAll('.detail-field').forEach(detailField => {
        const amorphField = detailField.querySelector('.amorph-field') as HTMLElement;
        if (!amorphField) return;
        
        const fieldName = amorphField.dataset.field || (detailField as HTMLElement).dataset.fieldKey || '';
        const selected = isFieldSelected(itemSlug, fieldName);
        
        amorphField.classList.toggle('is-selected', selected);
        
        if (selected) {
          const field = fields.find(f => f.itemSlug === itemSlug && f.fieldName === fieldName);
          if (field) applySelectionColor(amorphField, field.color);
        } else {
          amorphField.style.removeProperty('--selection-color');
          amorphField.style.removeProperty('--selection-bg');
          amorphField.style.removeProperty('--selection-border');
        }
      });
    }
    
    fieldsContainer?.addEventListener('click', handleFieldClick);
    selectionClear?.addEventListener('click', () => { clearSelection(); updateSelectionUI(); });
    
    // Compare-Button wird bereits von initApp() in Base.astro behandelt
    
    subscribe(updateSelectionUI);
    updateSelectionUI();
    
    console.log('[Detail] Field selection initialized for', itemName);
  });
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFieldSelection);
  } else {
    initFieldSelection();
  }
</script>

<style>
  .detail-field {
    transition: opacity 0.2s ease;
  }
  
  .detail-field[style*="display: none"] {
    opacity: 0;
  }
</style>
